# -*- coding: utf-8 -*-
"""MCP ZERODHA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f-kHbt0dbumoGUlI2YepU_ifwjdh9VlD
"""

# Install dependencies
!pip install -q fastmcp pydantic pydantic-settings sqlalchemy aiosqlite structlog python-dotenv

# Create directory structure
!mkdir -p src/mcp src/core src/adapters src/models src/utils src/database
!mkdir -p tests/unit tests/integration logs data docs scripts

# Create __init__.py files
!touch src/__init__.py
!touch src/mcp/__init__.py src/core/__init__.py src/adapters/__init__.py
!touch src/models/__init__.py src/utils/__init__.py src/database/__init__.py
!touch tests/__init__.py tests/unit/__init__.py tests/integration/__init__.py

print("âœ… Environment setup complete!")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile src/config.py
# """Configuration Management"""
# from pydantic_settings import BaseSettings
# from typing import Literal
# 
# class Settings(BaseSettings):
#     """Application configuration"""
# 
#     # Environment
#     ENVIRONMENT: Literal["development", "production"] = "development"
#     DEBUG: bool = True
#     DRY_RUN: bool = False
# 
#     # Broker Configuration
#     BROKER_TYPE: Literal["mock", "kite"] = "mock"
#     KITE_API_KEY: str = ""
#     KITE_API_SECRET: str = ""
#     KITE_ACCESS_TOKEN: str = ""
# 
#     # Risk Management
#     MAX_POSITION_SIZE: float = 500000.0
#     MAX_TOTAL_EXPOSURE: float = 2000000.0
#     MAX_POSITIONS: int = 10
#     MAX_DAILY_LOSS_PCT: float = 5.0
#     MAX_POSITION_PCT: float = 25.0
# 
#     # Order Defaults
#     DEFAULT_PRODUCT: Literal["MIS", "CNC", "NRML"] = "MIS"
# 
#     # Database
#     DATABASE_URL: str = "sqlite+aiosqlite:///./data/trading.db"
# 
#     # Logging
#     LOG_LEVEL: Literal["DEBUG", "INFO", "WARNING", "ERROR"] = "INFO"
#     LOG_DIR: str = "./logs"
# 
#     class Config:
#         env_file = ".env"
#         env_file_encoding = "utf-8"
# 
# settings = Settings()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile src/utils/logger.py
# """Structured Logging Setup"""
# import structlog
# import logging
# from pathlib import Path
# 
# def setup_logging():
#     """Configure structured logging"""
#     log_dir = Path("./logs")
#     log_dir.mkdir(exist_ok=True)
# 
#     structlog.configure(
#         processors=[
#             structlog.processors.add_log_level,
#             structlog.processors.TimeStamper(fmt="iso"),
#             structlog.processors.StackInfoRenderer(),
#             structlog.processors.format_exc_info,
#             structlog.processors.JSONRenderer()
#         ],
#         wrapper_class=structlog.make_filtering_bound_logger(logging.INFO),
#         context_class=dict,
#         logger_factory=structlog.PrintLoggerFactory(),
#         cache_logger_on_first_use=True,
#     )
# 
#     return structlog.get_logger()
# 
# logger = setup_logging()
# order_logger = logger.bind(log_type="order")
# risk_logger = logger.bind(log_type="risk")
# system_logger = logger.bind(log_type="system")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile src/models/signal.py
# """Trading Signal Model"""
# from pydantic import BaseModel, Field, field_validator
# from typing import Literal, Optional
# from datetime import datetime
# 
# class TradingSignal(BaseModel):
#     """Incoming trading signal from AI or external source"""
# 
#     symbol: str = Field(..., description="Trading symbol (e.g., SBIN, RELIANCE)")
#     action: Literal["BUY", "SELL"] = Field(..., description="Trade direction")
#     quantity: int = Field(..., gt=0, description="Number of shares")
#     order_type: Literal["MARKET", "LIMIT"] = "MARKET"
#     price: Optional[float] = Field(None, ge=0, description="Limit price (required for LIMIT orders)")
# 
#     signal_source: str = Field(default="manual", description="Source of signal")
#     confidence: float = Field(default=1.0, ge=0, le=1, description="Signal confidence 0-1")
#     notes: Optional[str] = Field(None, description="Additional context")
# 
#     timestamp: datetime = Field(default_factory=datetime.now)
# 
#     @field_validator('price')
#     @classmethod
#     def validate_limit_price(cls, v, info):
#         """Ensure LIMIT orders have a price"""
#         if info.data.get('order_type') == 'LIMIT' and v is None:
#             raise ValueError("LIMIT orders must specify a price")
#         return v
# 
#     @field_validator('symbol')
#     @classmethod
#     def validate_symbol(cls, v):
#         """Basic symbol validation"""
#         v = v.upper().strip()
#         if not v.replace('&', '').replace('-', '').isalnum():
#             raise ValueError("Symbol must be alphanumeric")
#         if len(v) < 2 or len(v) > 20:
#             raise ValueError("Symbol length must be 2-20 characters")
#         return v
# 
#     model_config = {
#         "json_schema_extra": {
#             "example": {
#                 "symbol": "SBIN",
#                 "action": "BUY",
#                 "quantity": 10,
#                 "order_type": "MARKET",
#                 "signal_source": "claude_ai",
#                 "confidence": 0.85
#             }
#         }
#     }

# Commented out IPython magic to ensure Python compatibility.
# %%writefile src/models/order.py
# """Order Model and Status"""
# from pydantic import BaseModel, Field
# from typing import Literal, Optional
# from datetime import datetime
# from enum import Enum
# import uuid
# 
# class OrderStatus(str, Enum):
#     """Order lifecycle states"""
#     PENDING = "PENDING"
#     SUBMITTED = "SUBMITTED"
#     ACCEPTED = "ACCEPTED"
#     REJECTED = "REJECTED"
#     PARTIALLY_FILLED = "PARTIALLY_FILLED"
#     FILLED = "FILLED"
#     CANCELLED = "CANCELLED"
#     EXPIRED = "EXPIRED"
# 
# class Order(BaseModel):
#     """Internal order representation"""
# 
#     # Identification
#     order_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
#     broker_order_id: Optional[str] = None
# 
#     # Core details
#     symbol: str
#     action: Literal["BUY", "SELL"]
#     quantity: int = Field(gt=0)
#     order_type: Literal["MARKET", "LIMIT", "STOP_LOSS"]
#     price: Optional[float] = Field(None, ge=0)
# 
#     # Product type
#     product: Literal["MIS", "CNC", "NRML"] = "MIS"
# 
#     # Status tracking
#     status: OrderStatus = OrderStatus.PENDING
#     status_message: str = ""
# 
#     # Execution details
#     filled_quantity: int = 0
#     average_price: Optional[float] = None
# 
#     # Timestamps
#     created_at: datetime = Field(default_factory=datetime.now)
#     submitted_at: Optional[datetime] = None
#     filled_at: Optional[datetime] = None
# 
#     # Metadata
#     signal_source: str = "manual"
#     tags: list = Field(default_factory=list)
# 
#     def is_complete(self) -> bool:
#         """Check if order is in terminal state"""
#         return self.status in [
#             OrderStatus.FILLED,
#             OrderStatus.REJECTED,
#             OrderStatus.CANCELLED,
#             OrderStatus.EXPIRED
#         ]
# 
#     def is_open(self) -> bool:
#         """Check if order can still be modified/cancelled"""
#         return self.status in [
#             OrderStatus.PENDING,
#             OrderStatus.SUBMITTED,
#             OrderStatus.ACCEPTED,
#             OrderStatus.PARTIALLY_FILLED
#         ]
# 
#     def mark_submitted(self, broker_order_id: str):
#         """Update order when submitted to broker"""
#         self.status = OrderStatus.SUBMITTED
#         self.broker_order_id = broker_order_id
#         self.submitted_at = datetime.now()
# 
#     def mark_filled(self, avg_price: float, quantity: Optional[int] = None):
#         """Update order when filled"""
#         if quantity is None:
#             quantity = self.quantity
# 
#         self.filled_quantity = quantity
#         self.average_price = avg_price
#         self.status = OrderStatus.FILLED if quantity == self.quantity else OrderStatus.PARTIALLY_FILLED
#         self.filled_at = datetime.now()
# 
#     def mark_rejected(self, reason: str):
#         """Update order when rejected"""
#         self.status = OrderStatus.REJECTED
#         self.status_message = reason
# 
#     model_config = {"use_enum_values": True}

# Commented out IPython magic to ensure Python compatibility.
# %%writefile src/models/position.py
# """Position Model"""
# from pydantic import BaseModel, Field
# from datetime import datetime
# 
# class Position(BaseModel):
#     """Represents an open position in the portfolio"""
# 
#     symbol: str
#     quantity: int  # Positive for long, negative for short
#     average_price: float = Field(gt=0)
# 
#     # Current market data
#     last_price: float = Field(gt=0)
#     last_updated: datetime = Field(default_factory=datetime.now)
# 
#     # P&L tracking
#     realized_pnl: float = 0.0
# 
#     @property
#     def unrealized_pnl(self) -> float:
#         """Calculate unrealized P&L"""
#         return (self.last_price - self.average_price) * self.quantity
# 
#     @property
#     def total_pnl(self) -> float:
#         """Total P&L (realized + unrealized)"""
#         return self.realized_pnl + self.unrealized_pnl
# 
#     @property
#     def pnl_percentage(self) -> float:
#         """P&L as percentage of invested amount"""
#         invested = self.average_price * abs(self.quantity)
#         if invested == 0:
#             return 0.0
#         return (self.unrealized_pnl / invested) * 100
# 
#     @property
#     def current_value(self) -> float:
#         """Current market value of position"""
#         return self.last_price * abs(self.quantity)
# 
#     @property
#     def is_long(self) -> bool:
#         return self.quantity > 0
# 
#     @property
#     def is_short(self) -> bool:
#         return self.quantity < 0
# 
#     def update_price(self, new_price: float):
#         """Update last price"""
#         self.last_price = new_price
#         self.last_updated = datetime.now()
# 
#     def add_quantity(self, qty: int, price: float):
#         """Add to position (average in or reduce)"""
#         if (self.quantity > 0 and qty < 0) or (self.quantity < 0 and qty > 0):
#             # Reducing position - realize P&L
#             close_qty = min(abs(qty), abs(self.quantity))
#             self.realized_pnl += (price - self.average_price) * close_qty * (1 if self.quantity > 0 else -1)
#             self.quantity += qty
#         else:
#             # Adding to position - average price
#             total_value = (self.average_price * abs(self.quantity)) + (price * abs(qty))
#             self.quantity += qty
#             if self.quantity != 0:
#                 self.average_price = total_value / abs(self.quantity)
# 
#         self.last_price = price
#         self.last_updated = datetime.now()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile src/models/portfolio.py
# """Portfolio Model"""
# from pydantic import BaseModel, Field
# from datetime import datetime
# from typing import Dict, Optional
# 
# class Portfolio(BaseModel):
#     """Overall portfolio state"""
# 
#     positions: Dict[str, 'Position'] = Field(default_factory=dict)
# 
#     # Capital tracking
#     initial_capital: float = Field(default=1000000.0)
#     available_margin: float = Field(default=1000000.0)
# 
#     # P&L tracking
#     realized_pnl_today: float = 0.0
#     total_realized_pnl: float = 0.0
# 
#     # Metadata
#     last_updated: datetime = Field(default_factory=datetime.now)
# 
#     @property
#     def total_unrealized_pnl(self) -> float:
#         """Sum of all unrealized P&L"""
#         return sum(pos.unrealized_pnl for pos in self.positions.values())
# 
#     @property
#     def total_pnl(self) -> float:
#         """Total P&L (realized + unrealized)"""
#         return self.total_realized_pnl + self.total_unrealized_pnl
# 
#     @property
#     def total_exposure(self) -> float:
#         """Total capital deployed in positions"""
#         return sum(pos.average_price * abs(pos.quantity) for pos in self.positions.values())
# 
#     @property
#     def portfolio_value(self) -> float:
#         """Current total portfolio value"""
#         return self.initial_capital + self.total_pnl
# 
#     @property
#     def position_count(self) -> int:
#         """Number of open positions"""
#         return len(self.positions)
# 
#     @property
#     def pnl_percentage(self) -> float:
#         """Portfolio P&L as percentage"""
#         if self.initial_capital == 0:
#             return 0.0
#         return (self.total_pnl / self.initial_capital) * 100
# 
#     def get_position(self, symbol: str) -> Optional['Position']:
#         """Get position by symbol"""
#         return self.positions.get(symbol)
# 
#     def has_position(self, symbol: str) -> bool:
#         """Check if position exists"""
#         return symbol in self.positions
# 
#     def update_position(self, symbol: str, position: 'Position'):
#         """Update or create position"""
#         if position.quantity == 0:
#             if symbol in self.positions:
#                 closed_position = self.positions.pop(symbol)
#                 self.realized_pnl_today += closed_position.realized_pnl
#                 self.total_realized_pnl += closed_position.realized_pnl
#         else:
#             self.positions[symbol] = position
# 
#         self.last_updated = datetime.now()
# 
#     def update_prices(self, price_map: Dict[str, float]):
#         """Bulk update prices for all positions"""
#         for symbol, position in self.positions.items():
#             if symbol in price_map:
#                 position.update_price(price_map[symbol])
#         self.last_updated = datetime.now()
# 
#     def calculate_available_margin(self) -> float:
#         """Calculate available margin after positions"""
#         used_margin = self.total_exposure
#         return self.initial_capital - used_margin + self.total_realized_pnl
# 
#     def to_summary(self) -> dict:
#         """Get portfolio summary"""
#         return {
#             "portfolio_value": round(self.portfolio_value, 2),
#             "initial_capital": self.initial_capital,
#             "total_pnl": round(self.total_pnl, 2),
#             "pnl_percentage": round(self.pnl_percentage, 2),
#             "realized_pnl": round(self.total_realized_pnl, 2),
#             "unrealized_pnl": round(self.total_unrealized_pnl, 2),
#             "total_exposure": round(self.total_exposure, 2),
#             "available_margin": round(self.available_margin, 2),
#             "position_count": self.position_count,
#             "positions": {
#                 symbol: {
#                     "quantity": pos.quantity,
#                     "avg_price": round(pos.average_price, 2),
#                     "last_price": round(pos.last_price, 2),
#                     "pnl": round(pos.total_pnl, 2),
#                     "pnl_pct": round(pos.pnl_percentage, 2)
#                 }
#                 for symbol, pos in self.positions.items()
#             }
#         }
# 
# # Forward reference resolution
# from src.models.position import Position
# Portfolio.model_rebuild()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile src/adapters/base.py
# """Base Broker Adapter Interface"""
# from abc import ABC, abstractmethod
# from typing import List, Dict, Optional
# from pydantic import BaseModel
# from datetime import datetime
# 
# class OrderResponse(BaseModel):
#     """Response from broker after order submission"""
#     order_id: str
#     status: str
#     message: str
#     broker_order_id: Optional[str] = None
# 
# class Quote(BaseModel):
#     """Market quote data"""
#     symbol: str
#     last_price: float
#     bid: float
#     ask: float
#     volume: int
#     timestamp: datetime
# 
# class BrokerAdapter(ABC):
#     """Abstract base class for broker implementations"""
# 
#     @abstractmethod
#     async def place_order(self, order: 'Order') -> OrderResponse:
#         """Place order with broker"""
#         pass
# 
#     @abstractmethod
#     async def get_positions(self) -> List['Position']:
#         """Fetch current positions"""
#         pass
# 
#     @abstractmethod
#     async def get_order_status(self, order_id: str) -> 'OrderStatus':
#         """Get order status"""
#         pass
# 
#     @abstractmethod
#     async def cancel_order(self, order_id: str) -> bool:
#         """Cancel pending order"""
#         pass
# 
#     @abstractmethod
#     async def get_quotes(self, symbols: List[str]) -> Dict[str, Quote]:
#         """Get market quotes"""
#         pass

# Commented out IPython magic to ensure Python compatibility.
# %%writefile src/adapters/mock_broker.py
# """Mock Broker Implementation for Development"""
# import asyncio
# import random
# from typing import List, Dict
# from datetime import datetime
# from src.adapters.base import BrokerAdapter, OrderResponse, Quote
# from src.models.order import Order, OrderStatus
# from src.models.position import Position
# from src.utils.logger import system_logger
# 
# class MockBrokerAdapter(BrokerAdapter):
#     """Simulates broker behavior for testing without API"""
# 
#     def __init__(self):
#         self.positions: Dict[str, Position] = {}
#         self.mock_prices: Dict[str, float] = {
#             "SBIN": 580.50,
#             "RELIANCE": 2850.00,
#             "TCS": 3650.00,
#             "INFY": 1580.00,
#             "HDFCBANK": 1720.00,
#             "ICICIBANK": 1050.00,
#             "ITC": 450.00,
#             "BHARTIARTL": 1280.00,
#             "HINDUNILVR": 2580.00,
#             "LT": 3520.00
#         }
#         system_logger.info("mock_broker_initialized")
# 
#     async def place_order(self, order: Order) -> OrderResponse:
#         """Simulate order placement"""
#         await asyncio.sleep(random.uniform(0.05, 0.2))
# 
#         broker_order_id = f"MOCK-{datetime.now().strftime('%Y%m%d%H%M%S')}-{random.randint(1000, 9999)}"
# 
#         if random.random() < 0.05:
#             rejection_reasons = [
#                 "Insufficient margin",
#                 "Invalid symbol",
#                 "Market closed",
#                 "RMS rejection"
#             ]
#             return OrderResponse(
#                 order_id=order.order_id,
#                 status="REJECTED",
#                 message=random.choice(rejection_reasons),
#                 broker_order_id=None
#             )
# 
#         system_logger.info(
#             "mock_order_placed",
#             order_id=order.order_id,
#             broker_order_id=broker_order_id,
#             symbol=order.symbol
#         )
# 
#         asyncio.create_task(self._simulate_fill(order, broker_order_id))
# 
#         return OrderResponse(
#             order_id=order.order_id,
#             status="SUBMITTED",
#             message="Order placed successfully",
#             broker_order_id=broker_order_id
#         )
# 
#     async def _simulate_fill(self, order: Order, broker_order_id: str):
#         """Simulate order fill"""
#         await asyncio.sleep(random.uniform(0.1, 1.0))
# 
#         base_price = self.mock_prices.get(order.symbol, 1000.0)
# 
#         if order.order_type == "MARKET":
#             if random.random() < 0.99:
#                 slippage = random.uniform(0.0005, 0.0015)
#                 if order.action == "BUY":
#                     fill_price = base_price * (1 + slippage)
#                 else:
#                     fill_price = base_price * (1 - slippage)
# 
#                 order.mark_filled(fill_price, order.quantity)
#                 self._update_mock_position(order, fill_price)
# 
#                 system_logger.info(
#                     "mock_order_filled",
#                     order_id=order.order_id,
#                     broker_order_id=broker_order_id,
#                     symbol=order.symbol,
#                     fill_price=fill_price
#                 )
#         elif order.order_type == "LIMIT":
#             if random.random() < 0.70:
#                 fill_price = order.price
#                 order.mark_filled(fill_price, order.quantity)
#                 self._update_mock_position(order, fill_price)
# 
#                 system_logger.info("mock_limit_order_filled", order_id=order.order_id)
# 
#     def _update_mock_position(self, order: Order, fill_price: float):
#         """Update internal mock positions"""
#         symbol = order.symbol
#         quantity = order.quantity if order.action == "BUY" else -order.quantity
# 
#         if symbol in self.positions:
#             position = self.positions[symbol]
#             position.add_quantity(quantity, fill_price)
# 
#             if position.quantity == 0:
#                 del self.positions[symbol]
#         else:
#             self.positions[symbol] = Position(
#                 symbol=symbol,
#                 quantity=quantity,
#                 average_price=fill_price,
#                 last_price=fill_price
#             )
# 
#     async def get_positions(self) -> List[Position]:
#         """Return current mock positions"""
#         for position in self.positions.values():
#             if position.symbol in self.mock_prices:
#                 movement = random.uniform(-0.005, 0.005)
#                 new_price = self.mock_prices[position.symbol] * (1 + movement)
#                 position.update_price(new_price)
# 
#         return list(self.positions.values())
# 
#     async def get_order_status(self, order_id: str) -> OrderStatus:
#         """Return mock order status"""
#         await asyncio.sleep(0.05)
#         return OrderStatus.FILLED
# 
#     async def cancel_order(self, order_id: str) -> bool:
#         """Simulate order cancellation"""
#         await asyncio.sleep(0.1)
#         success = random.random() < 0.90
# 
#         if success:
#             system_logger.info("mock_order_cancelled", order_id=order_id)
#         else:
#             system_logger.warning("mock_cancel_failed", order_id=order_id)
# 
#         return success
# 
#     async def get_quotes(self, symbols: List[str]) -> Dict[str, Quote]:
#         """Return mock quotes"""
#         await asyncio.sleep(0.05)
# 
#         quotes = {}
#         for symbol in symbols:
#             if symbol in self.mock_prices:
#                 base_price = self.mock_prices[symbol]
#                 spread = base_price * 0.0005
#                 movement = random.uniform(-0.002, 0.002)
#                 current_price = base_price * (1 + movement)
# 
#                 quotes[symbol] = Quote(
#                     symbol=symbol,
#                     last_price=current_price,
#                     bid=current_price - spread,
#                     ask=current_price + spread,
#                     volume=random.randint(100000, 1000000),
#                     timestamp=datetime.now()
#                 )
# 
#                 self.mock_prices[symbol] = current_price
# 
#         return quotes

# Test all imports
import sys
sys.path.insert(0, '/content')

from src.config import settings
from src.utils.logger import system_logger
from src.models.signal import TradingSignal
from src.models.order import Order
from src.models.position import Position
from src.models.portfolio import Portfolio
from src.adapters.mock_broker import MockBrokerAdapter

print("âœ… All imports successful!")
print(f"ðŸ“ Config loaded: {settings.BROKER_TYPE}")
print(f"ðŸ“Š Initial capital: â‚¹{settings.MAX_POSITION_SIZE:,.2f}")

import asyncio

async def test_system():
    """Quick test of the trading system"""
    print("ðŸš€ Testing Trading System...\\n")

    # Initialize
    broker = MockBrokerAdapter()
    print("âœ… Broker initialized")

    # Create test signal
    signal = TradingSignal(
        symbol="SBIN",
        action="BUY",
        quantity=10,
        order_type="MARKET"
    )
    print(f"âœ… Signal created: {signal.symbol} {signal.action} {signal.quantity}")

    # Create order
    order = Order(
        symbol=signal.symbol,
        action=signal.action,
        quantity=signal.quantity,
        order_type=signal.order_type
    )
    print(f"âœ… Order created: {order.order_id}")

    # Submit order
    response = await broker.place_order(order)
    print(f"âœ… Order submitted: {response.status}")

    # Wait for fill
    print("â³ Waiting for order to fill...")
    await asyncio.sleep(2)

    # Check positions
    positions = await broker.get_positions()
    print(f"\\nðŸ“Š Positions: {len(positions)}")

    if positions:
        pos = positions[0]
        print(f"   Symbol: {pos.symbol}")
        print(f"   Quantity: {pos.quantity}")
        print(f"   Avg Price: â‚¹{pos.average_price:.2f}")
        print(f"   P&L: â‚¹{pos.total_pnl:.2f}")

    print("\\n" + "="*50)
    print("âœ… System test PASSED!")
    print("="*50)

# Run test
await test_system()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile .env
# ENVIRONMENT=development
# DEBUG=true
# DRY_RUN=false
# BROKER_TYPE=mock
# 
# # Zerodha Kite (fill when ready)
# KITE_API_KEY=
# KITE_API_SECRET=
# KITE_ACCESS_TOKEN=
# 
# # Risk Management
# MAX_POSITION_SIZE=500000.0
# MAX_TOTAL_EXPOSURE=2000000.0
# MAX_POSITIONS=10
# MAX_DAILY_LOSS_PCT=5.0

# Create ZIP for download
!zip -r trading-server.zip src/ .env README.md

from google.colab import files
files.download('trading-server.zip')

print("âœ… Package created and ready for download!")
print("\\nðŸ“¦ Next steps:")
print("1. Extract the ZIP file")
print("2. Create GitHub repository")
print("3. Push code to GitHub")
print("4. Get Kite API keys when ready")
print("5. Come back and integrate!")

import os

# Step 1: Configure Git
print("Configuring Git...")
!git config --global user.name "Parth2004124"
!git config --global user.email "parthpatel2004124@gmail.com"

# Step 2: Create required files
print("\nCreating required files...")

# requirements.txt
with open("requirements.txt", "w") as f:
    f.write("""# Core Dependencies
fastmcp>=0.1.0
pydantic>=2.0.0
pydantic-settings>=2.0.0
sqlalchemy>=2.0.0
aiosqlite>=0.19.0
structlog>=23.0.0
python-dotenv>=1.0.0

# Optional Broker
# kiteconnect>=4.0.0

# Testing
pytest>=7.0.0
pytest-asyncio>=0.21.0
pytest-cov>=4.0.0

# Dev Tools
black>=23.0.0
ruff>=0.1.0
mypy>=1.0.0
""")

# .gitignore
with open(".gitignore", "w") as f:
    f.write("""__pycache__/
*.py[cod]
*.egg-info/
build/
dist/

venv/
env/

.vscode/
.idea/

.pytest_cache/
.coverage
htmlcov/

.env
.env.local

logs/
*.log
*.db
*.sqlite

.DS_Store
Thumbs.db
""")

# README.md
with open("README.md", "w") as f:
    f.write("""# Zerodha MCP Trading Server

Production-grade MCP-compliant trading server designed for Zerodha Kite Connect.
Supports mock trading, risk controls, and future live execution.

## Features
- MCP protocol compatible
- Mock broker for safe testing
- Risk management and circuit breakers
- Portfolio and order lifecycle tracking
- Kite adapter ready (API keys pending)

## Status
- Phase 1: Mock Trading complete
- Phase 2: Kite Integration pending
- Phase 3: Live Execution locked

Educational use only.
""")

# LICENSE
with open("LICENSE", "w") as f:
    f.write("""MIT License

Copyright (c) 2025 Parth Bhosale
""")

# Step 3: Init git
print("\nInitializing Git...")
!git init

# Step 4: Add files
print("\nAdding files...")
!git add .

# Step 5: Commit
print("\nCommitting...")
!git commit -m "Initial commit: MCP trading server with mock broker, risk management, and Kite-ready architecture"

# Step 6: Remote setup
print("\nSetting remote...")
!git remote remove origin || true
!git remote add origin https://github.com/Parth2004124/Zerodha-MCP.git

# Step 7: Branch
!git branch -M main

# Step 8: Push
print("\nPushing to GitHub...")
print("Authenticate using GitHub Personal Access Token as password")
!git push -u origin main --force

print("\nPush complete")
print("Repository: https://github.com/Parth2004124/Zerodha-MCP")